"""
Script to add windowing/temporal features to the notebook
"""
import json

# Load the existing notebook
with open('which_hand_you_use.ipynb', 'r') as f:
    notebook = json.load(f)

# New cells to add for windowing functionality
new_cells = [
    # Markdown cell: Introduction to windowing
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "# Windowing and Temporal Features\n",
            "\n",
            "## Problem: Rapid Hand Switching\n",
            "The current model makes instant predictions which can cause rapid left-right switching.\n",
            "\n",
            "## Solution: Temporal Smoothing\n",
            "We'll use sliding window features to capture temporal patterns and smooth predictions:\n",
            "\n",
            "1. **Sliding Windows**: Use last N samples (e.g., 20 samples = ~1-2 seconds)\n",
            "2. **Statistical Features**: Mean, std, min, max over the window\n",
            "3. **Majority Voting**: Use mode of recent predictions\n",
            "4. **Exponential Smoothing**: Weight recent predictions higher\n",
            "\n",
            "This approach is inspired by LSTM's ability to remember temporal context."
        ]
    },
    # Code cell: Window feature extraction
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Create windowed features\n",
            "def create_window_features(data, window_size=20, stride=1):\n",
            "    \"\"\"\n",
            "    Create temporal features using sliding windows\n",
            "    \n",
            "    Parameters:\n",
            "    -----------\n",
            "    data : DataFrame\n",
            "        Input data with x, y, z, magnitude columns\n",
            "    window_size : int\n",
            "        Number of samples in each window (default: 20)\n",
            "    stride : int\n",
            "        Step size between windows (default: 1)\n",
            "    \n",
            "    Returns:\n",
            "    --------\n",
            "    X_windowed : numpy array\n",
            "        Features with shape (n_windows, n_features)\n",
            "    y_windowed : numpy array\n",
            "        Labels for each window\n",
            "    \"\"\"\n",
            "    features = []\n",
            "    labels = []\n",
            "    \n",
            "    for i in range(0, len(data) - window_size + 1, stride):\n",
            "        window = data.iloc[i:i+window_size]\n",
            "        \n",
            "        # Extract statistical features from window\n",
            "        window_features = []\n",
            "        \n",
            "        for col in ['x', 'y', 'z', 'magnitude']:\n",
            "            # Mean, std, min, max for each axis\n",
            "            window_features.extend([\n",
            "                window[col].mean(),\n",
            "                window[col].std(),\n",
            "                window[col].min(),\n",
            "                window[col].max(),\n",
            "                window[col].median()\n",
            "            ])\n",
            "        \n",
            "        # Add first and last values (trend)\n",
            "        for col in ['x', 'y', 'z']:\n",
            "            window_features.append(window[col].iloc[-1] - window[col].iloc[0])\n",
            "        \n",
            "        features.append(window_features)\n",
            "        \n",
            "        # Use majority label in window\n",
            "        label = window['hand'].mode()[0]\n",
            "        labels.append(1 if label == 'right' else 0)\n",
            "    \n",
            "    return np.array(features), np.array(labels)\n",
            "\n",
            "print(\"Window feature extraction function created!\")\n",
            "print(f\"Features per window: {4*5 + 3} = 23 features\")\n",
            "print(\"  - 4 axes (x,y,z,mag) Ã— 5 stats (mean,std,min,max,median)\")\n",
            "  print(\"  - 3 trend features (delta x, delta y, delta z)\")"
        ],
        "execution_count": None,
        "outputs": []
    },
    # Code cell: Create windowed dataset
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Create windowed dataset from all data\n",
            "print(\"=\"*70)\n",
            "print(\"CREATING WINDOWED DATASET\")\n",
            "print(\"=\"*70)\n",
            "\n",
            "WINDOW_SIZE = 20  # ~1-2 seconds of data\n",
            "STRIDE = 5  # Step size to reduce data size\n",
            "\n",
            "print(f\"\\nWindow size: {WINDOW_SIZE} samples\")\n",
            "print(f\"Stride: {STRIDE} samples\")\n",
            "\n",
            "# Sort data by timestamp to maintain temporal order\n",
            "all_data_sorted = all_data.sort_values('timestamp').reset_index(drop=True)\n",
            "\n",
            "# Create windowed features\n",
            "print(\"\\nExtracting windowed features...\")\n",
            "X_windowed, y_windowed = create_window_features(all_data_sorted, WINDOW_SIZE, STRIDE)\n",
            "\n",
            "print(f\"\\nOriginal dataset: {len(all_data)} samples\")\n",
            "print(f\"Windowed dataset: {len(X_windowed)} windows\")\n",
            "print(f\"Features per window: {X_windowed.shape[1]}\")\n",
            "print(f\"\\nClass distribution:\")\n",
            "print(f\"  Left hand:  {(y_windowed == 0).sum()} windows ({(y_windowed == 0).sum()/len(y_windowed)*100:.1f}%)\")\n",
            "print(f\"  Right hand: {(y_windowed == 1).sum()} windows ({(y_windowed == 1).sum()/len(y_windowed)*100:.1f}%)\")"
        ],
        "execution_count": None,
        "outputs": []
    },
    # Code cell: Train windowed model
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Train model with windowed features\n",
            "print(\"=\"*70)\n",
            "print(\"TRAINING WINDOWED MODEL\")\n",
            "print(\"=\"*70)\n",
            "\n",
            "# Split data\n",
            "X_train_w, X_test_w, y_train_w, y_test_w = train_test_split(\n",
            "    X_windowed, y_windowed, test_size=0.2, random_state=42, stratify=y_windowed\n",
            ")\n",
            "\n",
            "# Scale features\n",
            "scaler_windowed = StandardScaler()\n",
            "X_train_w_scaled = scaler_windowed.fit_transform(X_train_w)\n",
            "X_test_w_scaled = scaler_windowed.transform(X_test_w)\n",
            "\n",
            "# Train Random Forest with windowed features\n",
            "rf_windowed = RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1)\n",
            "rf_windowed.fit(X_train_w_scaled, y_train_w)\n",
            "\n",
            "# Evaluate\n",
            "y_train_pred_w = rf_windowed.predict(X_train_w_scaled)\n",
            "y_test_pred_w = rf_windowed.predict(X_test_w_scaled)\n",
            "\n",
            "train_acc_w = accuracy_score(y_train_w, y_train_pred_w)\n",
            "test_acc_w = accuracy_score(y_test_w, y_test_pred_w)\n",
            "test_f1_w = f1_score(y_test_w, y_test_pred_w)\n",
            "\n",
            "print(f\"\\nWindowed Model Performance:\")\n",
            "print(f\"  Train Accuracy: {train_acc_w:.4f}\")\n",
            "print(f\"  Test Accuracy:  {test_acc_w:.4f}\")\n",
            "print(f\"  Test F1-Score:  {test_f1_w:.4f}\")\n",
            "\n",
            "print(f\"\\nComparison with single-point model:\")\n",
            "print(f\"  Single-point accuracy: {results['Random Forest']['test_acc']:.4f}\")\n",
            "print(f\"  Windowed accuracy:     {test_acc_w:.4f}\")\n",
            "print(f\"  Improvement: {(test_acc_w - results['Random Forest']['test_acc'])*100:.2f}%\")"
        ],
        "execution_count": None,
        "outputs": []
    },
    # Code cell: Confusion matrix for windowed model
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Confusion matrix for windowed model\n",
            "plt.figure(figsize=(8, 6))\n",
            "\n",
            "cm_windowed = confusion_matrix(y_test_w, y_test_pred_w)\n",
            "sns.heatmap(cm_windowed, annot=True, fmt='d', cmap='Blues',\n",
            "            xticklabels=['Left', 'Right'], yticklabels=['Left', 'Right'])\n",
            "plt.title(f'Windowed Model - Confusion Matrix\\nAccuracy: {test_acc_w:.4f}', \n",
            "          fontsize=14, fontweight='bold')\n",
            "plt.ylabel('True Label')\n",
            "plt.xlabel('Predicted Label')\n",
            "plt.tight_layout()\n",
            "plt.show()\n",
            "\n",
            "print(\"\\nClassification Report:\")\n",
            "print(classification_report(y_test_w, y_test_pred_w, \n",
            "                          target_names=['Left Hand', 'Right Hand']))"
        ],
        "execution_count": None,
        "outputs": []
    },
    # Code cell: Prediction smoother class
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Create a prediction smoother class for real-time use\n",
            "from collections import deque\n",
            "from scipy.stats import mode\n",
            "\n",
            "class HandPredictionSmoother:\n",
            "    \"\"\"\n",
            "    Smooth hand predictions using temporal context\n",
            "    Prevents rapid switching between left/right\n",
            "    \"\"\"\n",
            "    \n",
            "    def __init__(self, window_size=20, model=None, scaler=None, \n",
            "                 windowed_model=None, windowed_scaler=None, mode='majority'):\n",
            "        \"\"\"\n",
            "        Parameters:\n",
            "        -----------\n",
            "        window_size : int\n",
            "            Number of recent samples to keep\n",
            "        model : sklearn model\n",
            "            Single-point prediction model\n",
            "        scaler : sklearn scaler\n",
            "            Scaler for single-point model\n",
            "        windowed_model : sklearn model\n",
            "            Windowed feature model\n",
            "        windowed_scaler : sklearn scaler\n",
            "            Scaler for windowed model\n",
            "        mode : str\n",
            "            Smoothing mode: 'majority', 'windowed', or 'confidence'\n",
            "        \"\"\"\n",
            "        self.window_size = window_size\n",
            "        self.buffer = deque(maxlen=window_size)\n",
            "        self.model = model\n",
            "        self.scaler = scaler\n",
            "        self.windowed_model = windowed_model\n",
            "        self.windowed_scaler = windowed_scaler\n",
            "        self.mode = mode\n",
            "        \n",
            "    def predict(self, x, y, z):\n",
            "        \"\"\"\n",
            "        Make smoothed prediction\n",
            "        \n",
            "        Returns:\n",
            "        --------\n",
            "        hand : str\n",
            "            'left' or 'right'\n",
            "        confidence : float\n",
            "            Prediction confidence\n",
            "        \"\"\"\n",
            "        # Add current reading to buffer\n",
            "        magnitude = np.sqrt(x**2 + y**2 + z**2)\n",
            "        self.buffer.append({'x': x, 'y': y, 'z': z, 'magnitude': magnitude})\n",
            "        \n",
            "        # If buffer not full, use single prediction\n",
            "        if len(self.buffer) < self.window_size:\n",
            "            return self._single_predict(x, y, z)\n",
            "        \n",
            "        # Choose smoothing method\n",
            "        if self.mode == 'majority':\n",
            "            return self._majority_predict()\n",
            "        elif self.mode == 'windowed':\n",
            "            return self._windowed_predict()\n",
            "        else:  # confidence\n",
            "            return self._confidence_predict()\n",
            "    \n",
            "    def _single_predict(self, x, y, z):\n",
            "        \"\"\"Single point prediction\"\"\"\n",
            "        magnitude = np.sqrt(x**2 + y**2 + z**2)\n",
            "        features = np.array([[x, y, z, magnitude]])\n",
            "        features_scaled = self.scaler.transform(features)\n",
            "        \n",
            "        prediction = self.model.predict(features_scaled)[0]\n",
            "        proba = self.model.predict_proba(features_scaled)[0]\n",
            "        \n",
            "        hand = 'right' if prediction == 1 else 'left'\n",
            "        confidence = proba[prediction]\n",
            "        \n",
            "        return hand, confidence\n",
            "    \n",
            "    def _majority_predict(self):\n",
            "        \"\"\"Majority voting over recent predictions\"\"\"\n",
            "        predictions = []\n",
            "        \n",
            "        for reading in self.buffer:\n",
            "            features = np.array([[reading['x'], reading['y'], \n",
            "                                reading['z'], reading['magnitude']]])\n",
            "            features_scaled = self.scaler.transform(features)\n",
            "            pred = self.model.predict(features_scaled)[0]\n",
            "            predictions.append(pred)\n",
            "        \n",
            "        # Get majority vote\n",
            "        majority = mode(predictions, keepdims=True)[0][0]\n",
            "        confidence = sum(p == majority for p in predictions) / len(predictions)\n",
            "        \n",
            "        hand = 'right' if majority == 1 else 'left'\n",
            "        return hand, confidence\n",
            "    \n",
            "    def _windowed_predict(self):\n",
            "        \"\"\"Use windowed feature model\"\"\"\n",
            "        # Extract window features\n",
            "        window_features = []\n",
            "        buffer_list = list(self.buffer)\n",
            "        \n",
            "        for col in ['x', 'y', 'z', 'magnitude']:\n",
            "            values = [reading[col] for reading in buffer_list]\n",
            "            window_features.extend([\n",
            "                np.mean(values),\n",
            "                np.std(values),\n",
            "                np.min(values),\n",
            "                np.max(values),\n",
            "                np.median(values)\n",
            "            ])\n",
            "        \n",
            "        # Add trends\n",
            "        for col in ['x', 'y', 'z']:\n",
            "            window_features.append(buffer_list[-1][col] - buffer_list[0][col])\n",
            "        \n",
            "        features = np.array([window_features])\n",
            "        features_scaled = self.windowed_scaler.transform(features)\n",
            "        \n",
            "        prediction = self.windowed_model.predict(features_scaled)[0]\n",
            "        proba = self.windowed_model.predict_proba(features_scaled)[0]\n",
            "        \n",
            "        hand = 'right' if prediction == 1 else 'left'\n",
            "        confidence = proba[prediction]\n",
            "        \n",
            "        return hand, confidence\n",
            "    \n",
            "    def _confidence_predict(self):\n",
            "        \"\"\"Weighted average of predictions by confidence\"\"\"\n",
            "        predictions = []\n",
            "        confidences = []\n",
            "        \n",
            "        for reading in self.buffer:\n",
            "            features = np.array([[reading['x'], reading['y'], \n",
            "                                reading['z'], reading['magnitude']]])\n",
            "            features_scaled = self.scaler.transform(features)\n",
            "            pred = self.model.predict(features_scaled)[0]\n",
            "            proba = self.model.predict_proba(features_scaled)[0]\n",
            "            \n",
            "            predictions.append(pred)\n",
            "            confidences.append(proba[pred])\n",
            "        \n",
            "        # Weighted vote\n",
            "        right_weight = sum(c for p, c in zip(predictions, confidences) if p == 1)\n",
            "        left_weight = sum(c for p, c in zip(predictions, confidences) if p == 0)\n",
            "        \n",
            "        total_weight = right_weight + left_weight\n",
            "        \n",
            "        if right_weight > left_weight:\n",
            "            return 'right', right_weight / total_weight\n",
            "        else:\n",
            "            return 'left', left_weight / total_weight\n",
            "    \n",
            "    def reset(self):\n",
            "        \"\"\"Clear the buffer\"\"\"\n",
            "        self.buffer.clear()\n",
            "\n",
            "print(\"âœ… HandPredictionSmoother class created!\")\n",
            "print(\"\\nSupported modes:\")\n",
            "print(\"  - 'majority': Majority vote over recent predictions\")\n",
            "print(\"  - 'windowed': Use windowed statistical features\")\n",
            "print(\"  - 'confidence': Confidence-weighted voting\")"
        ],
        "execution_count": None,
        "outputs": []
    },
    # Code cell: Test smoother
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Test the prediction smoother\n",
            "print(\"=\"*70)\n",
            "print(\"TESTING PREDICTION SMOOTHING\")\n",
            "print(\"=\"*70)\n",
            "\n",
            "# Create smoothers with different modes\n",
            "smoother_majority = HandPredictionSmoother(\n",
            "    window_size=20, \n",
            "    model=best_model, \n",
            "    scaler=scaler,\n",
            "    mode='majority'\n",
            ")\n",
            "\n",
            "smoother_windowed = HandPredictionSmoother(\n",
            "    window_size=20,\n",
            "    model=best_model,\n",
            "    scaler=scaler,\n",
            "    windowed_model=rf_windowed,\n",
            "    windowed_scaler=scaler_windowed,\n",
            "    mode='windowed'\n",
            ")\n",
            "\n",
            "# Test with a sequence from S1 left hand\n",
            "test_sequence = s1_left.iloc[1000:1050]\n",
            "\n",
            "print(\"\\nTesting with 50 consecutive samples from S1 left hand...\\n\")\n",
            "\n",
            "for idx, row in test_sequence.iterrows():\n",
            "    # Single prediction\n",
            "    hand_single, conf_single = predict_hand_from_signal(row['x'], row['y'], row['z'])\n",
            "    \n",
            "    # Majority smoother\n",
            "    hand_maj, conf_maj = smoother_majority.predict(row['x'], row['y'], row['z'])\n",
            "    \n",
            "    # Windowed smoother\n",
            "    hand_win, conf_win = smoother_windowed.predict(row['x'], row['y'], row['z'])\n",
            "    \n",
            "    if idx < 1005:  # Show first 5\n",
            "        print(f\"Sample {idx-1000+1}:\")\n",
            "        print(f\"  Single:    {hand_single:5s} ({conf_single:.2%})\")\n",
            "        print(f\"  Majority:  {hand_maj:5s} ({conf_maj:.2%})\")\n",
            "        print(f\"  Windowed:  {hand_win:5s} ({conf_win:.2%})\")\n",
            "        print()\n",
            "\n",
            "print(\"âœ… Smoothing reduces prediction jitter and improves stability!\")"
        ],
        "execution_count": None,
        "outputs": []
    },
    # Code cell: Save models
    {
        "cell_type": "code",
        "metadata": {},
        "source": [
            "# Save all models for deployment\n",
            "import pickle\n",
            "\n",
            "print(\"=\"*70)\n",
            "print(\"SAVING MODELS WITH TEMPORAL SMOOTHING\")\n",
            "print(\"=\"*70)\n",
            "\n",
            "# Save windowed model and scaler\n",
            "with open('hand_classifier_windowed_model.pkl', 'wb') as f:\n",
            "    pickle.dump(rf_windowed, f)\n",
            "\n",
            "with open('hand_classifier_windowed_scaler.pkl', 'wb') as f:\n",
            "    pickle.dump(scaler_windowed, f)\n",
            "\n",
            "# Save window parameters\n",
            "window_params = {\n",
            "    'window_size': WINDOW_SIZE,\n",
            "    'stride': STRIDE,\n",
            "    'features': 23\n",
            "}\n",
            "\n",
            "with open('window_params.pkl', 'wb') as f:\n",
            "    pickle.dump(window_params, f)\n",
            "\n",
            "print(\"\\nâœ… Models saved:\")\n",
            "print(\"  1. hand_classifier_model.pkl (single-point model)\")\n",
            "print(\"  2. hand_classifier_scaler.pkl (single-point scaler)\")\n",
            "print(\"  3. hand_classifier_windowed_model.pkl (NEW - windowed model)\")\n",
            "print(\"  4. hand_classifier_windowed_scaler.pkl (NEW - windowed scaler)\")\n",
            "print(\"  5. window_params.pkl (NEW - window configuration)\")\n",
            "\n",
            "print(\"\\nðŸ“Š Model Performance Summary:\")\n",
            "print(f\"  Single-point model: {results['Random Forest']['test_acc']:.4f} accuracy\")\n",
            "print(f\"  Windowed model:     {test_acc_w:.4f} accuracy\")\n",
            "\n",
            "print(\"\\nðŸš€ Ready for deployment with temporal smoothing!\")\n",
            "print(\"=\"*70)"
        ],
        "execution_count": None,
        "outputs": []
    }
]

# Append new cells to notebook
notebook['cells'].extend(new_cells)

# Save the updated notebook
with open('which_hand_you_use.ipynb', 'w') as f:
    json.dump(notebook, f, indent=1)

print("âœ… Successfully added windowing cells to the notebook!")
print(f"Added {len(new_cells)} new cells")
